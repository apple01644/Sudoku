<html>
    <head>
        <meta charset="utf-8"/>
        <title>Sudoku</title>
        <style>
            #table {
                border: 1px solid;
                width: min-content;
                display: flex;
                flex-direction: row;
            }
            .column {
                display: flex;
                flex-direction: column;
            }
            .cell {
                border: 1px solid;
                border-color: gray;
                width : 2rem;
                height: 2rem;
                font-family: 'Consolas';
                font-size: 2rem;
                display: flex;
                align-items: center;
                justify-content: center;
                user-select: none;
            }
            .cell[seleceted] {
                box-shadow: inset 0 0 10px blue;
            }
            .cell[disabled] {
                background-color: #EEEEEE;
            }
            .cell[error="1"] {
                background-color: pink;
            }
            .cell[error="2"] {
                background-color: red;
            }
            .bl-black { border-left-color: black; }
            .br-black { border-right-color: black; }
            .bt-black { border-top-color: black; }
            .bb-black { border-bottom-color: black; }
        </style>
        <script>
            let env = {
                dom: {},
                blank_count: 30,
                data: [
                    [null,null,null,null,null,null,null,null,null,],
                    [null,null,null,null,null,null,null,null,null,],
                    [null,null,null,null,null,null,null,null,null,],
                    [null,null,null,null,null,null,null,null,null,],
                    [null,null,null,null,null,null,null,null,null,],
                    [null,null,null,null,null,null,null,null,null,],
                    [null,null,null,null,null,null,null,null,null,],
                    [null,null,null,null,null,null,null,null,null,],
                    [null,null,null,null,null,null,null,null,null,],
                ],
                error: [
                    [0,0,0,0,0,0,0,0,0,],
                    [0,0,0,0,0,0,0,0,0,],
                    [0,0,0,0,0,0,0,0,0,],
                    [0,0,0,0,0,0,0,0,0,],
                    [0,0,0,0,0,0,0,0,0,],
                    [0,0,0,0,0,0,0,0,0,],
                    [0,0,0,0,0,0,0,0,0,],
                    [0,0,0,0,0,0,0,0,0,],
                    [0,0,0,0,0,0,0,0,0,],
                ],
                freeze: [
                    [false,false,false,false,false,false,false,false,false,],
                    [false,false,false,false,false,false,false,false,false,],
                    [false,false,false,false,false,false,false,false,false,],
                    [false,false,false,false,false,false,false,false,false,],
                    [false,false,false,false,false,false,false,false,false,],
                    [false,false,false,false,false,false,false,false,false,],
                    [false,false,false,false,false,false,false,false,false,],
                    [false,false,false,false,false,false,false,false,false,],
                    [false,false,false,false,false,false,false,false,false,],
                ],
                selected:{x:0,y:0},
            };
            function mark_error_on_table() {
                for (let x = 0; x < 9; ++x) {
                    for (let y = 0; y < 9; ++y) {
                        env.error[y][x] = 0;
                    }
                }
                let itr = [0,1,2,3,4,5,6,7,8];

                for (let i = 0; i < 9; ++i) {
                    let nums = itr.map(k => { return {x:i, y:k, num:env.data[k][i]}; })
                                  .filter(named_tup => named_tup.num !== null);
                    let error_found = false;
                    for (const dict of nums)
                    {
                        const count = nums.filter(named_tup => named_tup.num === dict.num).length;
                        if (count > 1)
                        {    
                            env.error[dict.y][dict.x] = 2;
                            error_found = true;
                        }
                    }
                    if (error_found)
                    {
                        itr.map(k => { 
                            if (env.error[k][i] == 0)
                                env.error[k][i] = 1;
                        });
                                  
                    }

                }
            }
            function update_table() {
                mark_error_on_table();
                for (let x = 0; x < 9; ++x) {
                    let cells = env.dom.columns[x].getElementsByClassName('cell');
                    for (let y = 0; y < 9; ++y) {
                        cells[y].innerText = env.data[y][x] || '';
                        cells[y].removeAttribute('seleceted');
                        if (env.selected.x == x && env.selected.y == y)
                            cells[y].setAttribute('seleceted', '');
                        cells[y].removeAttribute('disabled');
                        if (env.freeze[y][x] === true)
                            cells[y].setAttribute('disabled', '');
                        cells[y].setAttribute('error', env.error[y][x]);
                    }
                }
                const candiates = get_candiates(env.data, env.selected.x, env.selected.y);
                if (candiates.length === 0)
                    env.dom.hint.innerText = "Candiates: No possible candiates";
                else
                    env.dom.hint.innerText = "Candiates: " + candiates.join(', ');
            
                env.dom.title.innerText = 'Sudoku with {num} blanks'.replace('{num}', env.blank_count);
            }
            function get_candiates(data, x, y, debug) {
                let candiates = [1,2,3,4,5,6,7,8,9];
                let disqualified = [];
                for (let i = 0; i < 9; ++i)
                {
                    let num = data[i][x];
                    if (i !== y && num !== null && disqualified.indexOf(num) === -1)
                    {
                        if (debug === true) console.log(x,i,num);
                        disqualified.push(num);
                    }    
                    num = data[y][i];
                    if (i !== x && num !== null && disqualified.indexOf(num) === -1)
                    {
                        if (debug === true) console.log(x,i,num);
                        disqualified.push(num);
                    }
                    const base_x = 3 * Math.floor(x / 3);
                    const base_y = 3 * Math.floor(y / 3);
                    const x2 = base_x + i % 3;
                    const y2 = base_y + Math.floor(i / 3);
                    if (x2 !== x && y2 !== y) {
                        num = data[y2][x2];
                        if (num !== null && disqualified.indexOf(num) === -1)
                        {
                            if (debug === true) console.log(x2,y2,num);
                            disqualified.push(num);
                        }
                    }
                }

                return candiates.filter(k => disqualified.indexOf(k) === -1);
            }
            function shuffle(list) {
                let flag = {};
                let output = [];
                for (let x = 0; x < list.length; ++x)
                    flag[x] = Math.random();
                let A = Object.entries(flag).sort((a,b)=>a[1]-b[1]).map(t=>t[0]);
                for (let x = 0; x < A.length; ++x)
                    output.push(list[A[x]]);
                return output;
            }
            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            async function generate_table() {
                async function async_update_table() {
                    update_table();
                }
                let positions_to_fill = [];
                for (let x = 0; x < 9; ++x) {
                    for (let y = 0; y < 9; ++y) {
                        positions_to_fill.push({x:x, y:y});
                        env.data[y][x] = null;
                        env.freeze[y][x] = true;
                    }
                }
                let candiates_stack = [];
                const MODE_FORWARD = 1;
                const MODE_BACKWARD = 2;
                let mode = MODE_FORWARD;
                let max_attempt = -1;
                for (let time = 0; max_attempt === -1 ||time < max_attempt; ++time) {
                    if (mode === MODE_FORWARD) {
                        let index = candiates_stack.length;
                        if (index >= 81) break;
                        const position = positions_to_fill[index];
                        env.selected = {x:position.x, y:position.y};
                        let candiates = get_candiates(env.data, position.x, position.y);
                        if (candiates.length === 0)
                        {
                            mode = MODE_BACKWARD;
                        }
                        else
                        {
                            candiates = shuffle(candiates);
                            env.data[position.y][position.x] = candiates[candiates.length - 1];
                            candiates_stack.push(candiates);
                        }
                    }
                    else {
                        let index = candiates_stack.length - 1;
                        const position = positions_to_fill[index];
                        const candiates = candiates_stack[candiates_stack.length-1];
                        env.selected = {x:position.x, y:position.y};
                        if (candiates.length > 1) {
                            candiates.pop();
                            env.data[position.y][position.x] = candiates[candiates.length - 1];
                            mode = MODE_FORWARD;
                        } else {
                            env.data[position.y][position.x] = null;
                            candiates_stack.pop();
                        }
                    }
                    if (time % 1 === 0)
                    {
                        await async_update_table();
                        await sleep(1);
                    }
                }
                
                let blank_count = env.blank_count;
                const shuffled_positions_to_fill = shuffle(positions_to_fill);
                for (let x = 0; x < env.blank_count; ++x)
                {
                    const pos = shuffled_positions_to_fill[x];
                    env.data[pos.y][pos.x] = null;
                    env.freeze[pos.y][pos.x] = false;
                }
                
                console.log('finished');
                await async_update_table();
            }
            function body_onload() {
                console.log('initializing...');
                env.dom.table = document.getElementById("table");
                env.dom.hint = document.getElementById("hint");
                env.dom.title = document.getElementById("title");
                env.dom.columns = [];
                for (let x = 0; x < 9; ++x) {
                    let column = document.createElement("div");
                    for (let y = 0; y < 9; ++y) {
                        column.setAttribute('class','column');
                        let cell = document.createElement("div");
                        let classes = ['cell'];
                        
                        if (x%3 == 0)
                            classes.push('bl-black');
                        if (x%3 == 2)
                            classes.push('br-black');
                        if (y%3 == 0)
                            classes.push('bt-black');
                        if (y%3 == 2)
                            classes.push('bb-black');

                        cell.setAttribute('class', classes.join(' '));
                        cell.setAttribute(
                            'onclick', 
                            'env.selected = {x: {x}, y: {y}};'
                            .replace('{x}', x)
                            .replace('{y}', y)
                            + 'update_table();'
                        );
                        column.appendChild(cell);
                    }
                    env.dom.table.appendChild(column);
                    env.dom.columns.push(column);
                }
                setTimeout(() => generate_table(), 100);
                update_table();
                document.body.onkeydown = body_onkeydown;
            }
            function body_onkeydown(e) {
                const re_num = /(?<=Digit|Numpad)[123456789]/;
                if (['KeyA', 'ArrowLeft'].indexOf(e.code) !== -1)
                {
                    if (e.ctrlKey === true)
                        env.selected.x = 0;
                    else
                        env.selected.x = (env.selected.x + 9 - 1) % 9;
                }
                else if (['KeyD', 'ArrowRight'].indexOf(e.code) !== -1)
                {
                    if (e.ctrlKey === true)
                        env.selected.x = 8;
                    else
                     env.selected.x = (env.selected.x + 9 + 1) % 9;
                }
                else if (['KeyW', 'ArrowUp'].indexOf(e.code) !== -1)
                {
                    if (e.ctrlKey === true)
                        env.selected.y = 0;
                    else
                      env.selected.y = (env.selected.y + 9 - 1) % 9;
                }
                else if (['KeyS', 'ArrowDown'].indexOf(e.code) !== -1)
                {
                    if (e.ctrlKey === true)
                        env.selected.y = 8;
                    else
                       env.selected.y = (env.selected.y + 9 + 1) % 9;
                }
                else if (e.code.match(re_num) !== null)
                {
                    const num = e.code.match(re_num)[0];
                    if (env.freeze[env.selected.y][env.selected.x] === true) return;
                    env.data[env.selected.y][env.selected.x] = num;

                }
                update_table();
            }
        </script>
    </head>
    <body>
        <div style="display:flex; flex-direction: row;">
            <h1 id="title" style="margin: 0px 1rem 0px 0px;">Sudoku with 30 blanks</h1>
        </div>
        <input type="range" min="10" max="80" value="30" onchange="env.blank_count=this.value; update_table();"/>
        <input type="button" value="generate" onclick="generate_table()"/>
        <h3 id="hint" style="margin: 0px">Candiates:</h3>
        <div id="table">
        </div>
        <script>
            document.body.onload = body_onload;
        </script>
    </body>
</html>
